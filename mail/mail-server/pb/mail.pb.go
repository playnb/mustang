// Code generated by protoc-gen-gogo.
// source: mail.proto
// DO NOT EDIT!

/*
	Package pb is a generated protocol buffer package.

	It is generated from these files:
		mail.proto

	It has these top-level messages:
		MailHeader
		MailBody
		Result
		SendRequest
		SendResponse
		BroadcastRequest
		BroadcastResponse
		GetMailCountRequest
		GetMailCountResponse
		ListRequest
		MailHeaderWithID
		ListResponse
		MailIndex
		GetRequest
		GetResponse
		DeleteRequest
		DeleteResponse
		MarkAsReadRequest
		MarkAsReadResponse
		MarkAsUnreadRequest
		MarkAsUnreadResponse
		MarkAttachmentsAsReceivedRequest
		MarkAttachmentsAsReceivedResponse
		SetCustomDataRequest
		SetCustomDataResponse
		SubscribeRequest
		NewMailNotification
*/
package pb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import "errors"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// 邮件头是邮件是摘要信息，比较小。邮件列表返回的是邮件头。
// 服务器对邮件头中的数据是按请求原样保存，不会更改其中内容。
type MailHeader struct {
	From        []byte                        `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	FromNick    []byte                        `protobuf:"bytes,2,opt,name=from_nick,json=fromNick,proto3" json:"from_nick,omitempty"`
	To          []byte                        `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	ToNick      []byte                        `protobuf:"bytes,4,opt,name=to_nick,json=toNick,proto3" json:"to_nick,omitempty"`
	Title       []byte                        `protobuf:"bytes,5,opt,name=title,proto3" json:"title,omitempty"`
	Brief       []byte                        `protobuf:"bytes,6,opt,name=brief,proto3" json:"brief,omitempty"`
	BodyLen     uint32                        `protobuf:"varint,7,opt,name=body_len,json=bodyLen,proto3" json:"body_len,omitempty"`
	Attachments []*MailHeader_AttachmentBrief `protobuf:"bytes,8,rep,name=attachments" json:"attachments,omitempty"`
	Time        *MailHeader_Time              `protobuf:"bytes,9,opt,name=time" json:"time,omitempty"`
	Status      *MailHeader_Status            `protobuf:"bytes,10,opt,name=status" json:"status,omitempty"`
}

func (m *MailHeader) Reset()                    { *m = MailHeader{} }
func (m *MailHeader) String() string            { return proto.CompactTextString(m) }
func (*MailHeader) ProtoMessage()               {}
func (*MailHeader) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{0} }

func (m *MailHeader) GetFrom() []byte {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *MailHeader) GetFromNick() []byte {
	if m != nil {
		return m.FromNick
	}
	return nil
}

func (m *MailHeader) GetTo() []byte {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *MailHeader) GetToNick() []byte {
	if m != nil {
		return m.ToNick
	}
	return nil
}

func (m *MailHeader) GetTitle() []byte {
	if m != nil {
		return m.Title
	}
	return nil
}

func (m *MailHeader) GetBrief() []byte {
	if m != nil {
		return m.Brief
	}
	return nil
}

func (m *MailHeader) GetBodyLen() uint32 {
	if m != nil {
		return m.BodyLen
	}
	return 0
}

func (m *MailHeader) GetAttachments() []*MailHeader_AttachmentBrief {
	if m != nil {
		return m.Attachments
	}
	return nil
}

func (m *MailHeader) GetTime() *MailHeader_Time {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *MailHeader) GetStatus() *MailHeader_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type MailHeader_AttachmentBrief struct {
	Index uint32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Brief []byte `protobuf:"bytes,2,opt,name=brief,proto3" json:"brief,omitempty"`
	// 多数游戏的附件为道具
	ItemId uint64 `protobuf:"varint,5,opt,name=item_id,json=itemId,proto3" json:"item_id,omitempty"`
	Item   []byte `protobuf:"bytes,3,opt,name=item,proto3" json:"item,omitempty"`
	Count  uint32 `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *MailHeader_AttachmentBrief) Reset()         { *m = MailHeader_AttachmentBrief{} }
func (m *MailHeader_AttachmentBrief) String() string { return proto.CompactTextString(m) }
func (*MailHeader_AttachmentBrief) ProtoMessage()    {}
func (*MailHeader_AttachmentBrief) Descriptor() ([]byte, []int) {
	return fileDescriptorMail, []int{0, 0}
}

func (m *MailHeader_AttachmentBrief) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *MailHeader_AttachmentBrief) GetBrief() []byte {
	if m != nil {
		return m.Brief
	}
	return nil
}

func (m *MailHeader_AttachmentBrief) GetItemId() uint64 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *MailHeader_AttachmentBrief) GetItem() []byte {
	if m != nil {
		return m.Item
	}
	return nil
}

func (m *MailHeader_AttachmentBrief) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type MailHeader_Time struct {
	Send   int64 `protobuf:"varint,1,opt,name=send,proto3" json:"send,omitempty"`
	Expire int64 `protobuf:"varint,2,opt,name=expire,proto3" json:"expire,omitempty"`
}

func (m *MailHeader_Time) Reset()                    { *m = MailHeader_Time{} }
func (m *MailHeader_Time) String() string            { return proto.CompactTextString(m) }
func (*MailHeader_Time) ProtoMessage()               {}
func (*MailHeader_Time) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{0, 1} }

func (m *MailHeader_Time) GetSend() int64 {
	if m != nil {
		return m.Send
	}
	return 0
}

func (m *MailHeader_Time) GetExpire() int64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

type MailHeader_Status struct {
	Read                bool   `protobuf:"varint,1,opt,name=read,proto3" json:"read,omitempty"`
	AttachmentsReceived bool   `protobuf:"varint,2,opt,name=attachments_received,json=attachmentsReceived,proto3" json:"attachments_received,omitempty"`
	CustomData          []byte `protobuf:"bytes,3,opt,name=custom_data,json=customData,proto3" json:"custom_data,omitempty"`
}

func (m *MailHeader_Status) Reset()                    { *m = MailHeader_Status{} }
func (m *MailHeader_Status) String() string            { return proto.CompactTextString(m) }
func (*MailHeader_Status) ProtoMessage()               {}
func (*MailHeader_Status) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{0, 2} }

func (m *MailHeader_Status) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *MailHeader_Status) GetAttachmentsReceived() bool {
	if m != nil {
		return m.AttachmentsReceived
	}
	return false
}

func (m *MailHeader_Status) GetCustomData() []byte {
	if m != nil {
		return m.CustomData
	}
	return nil
}

// 邮件体是邮件正文和附件数据，比较大。邮件体须通过Get()方法单独获取。
type MailBody struct {
	Body        []byte                     `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	Attachments []*MailBody_AttachmentBody `protobuf:"bytes,2,rep,name=attachments" json:"attachments,omitempty"`
}

func (m *MailBody) Reset()                    { *m = MailBody{} }
func (m *MailBody) String() string            { return proto.CompactTextString(m) }
func (*MailBody) ProtoMessage()               {}
func (*MailBody) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{1} }

func (m *MailBody) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *MailBody) GetAttachments() []*MailBody_AttachmentBody {
	if m != nil {
		return m.Attachments
	}
	return nil
}

type MailBody_AttachmentBody struct {
	Index uint32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Body  []byte `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
}

func (m *MailBody_AttachmentBody) Reset()                    { *m = MailBody_AttachmentBody{} }
func (m *MailBody_AttachmentBody) String() string            { return proto.CompactTextString(m) }
func (*MailBody_AttachmentBody) ProtoMessage()               {}
func (*MailBody_AttachmentBody) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{1, 0} }

func (m *MailBody_AttachmentBody) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *MailBody_AttachmentBody) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

// 通用的结果消息
type Result struct {
	Ok    bool   `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *Result) Reset()                    { *m = Result{} }
func (m *Result) String() string            { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()               {}
func (*Result) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{2} }

func (m *Result) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *Result) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type SendRequest struct {
	Header *MailHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Body   *MailBody   `protobuf:"bytes,2,opt,name=body" json:"body,omitempty"`
}

func (m *SendRequest) Reset()                    { *m = SendRequest{} }
func (m *SendRequest) String() string            { return proto.CompactTextString(m) }
func (*SendRequest) ProtoMessage()               {}
func (*SendRequest) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{3} }

func (m *SendRequest) GetHeader() *MailHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *SendRequest) GetBody() *MailBody {
	if m != nil {
		return m.Body
	}
	return nil
}

type SendResponse struct {
	Result *Result `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
	MailId []byte  `protobuf:"bytes,3,opt,name=mail_id,json=mailId,proto3" json:"mail_id,omitempty"`
}

func (m *SendResponse) Reset()                    { *m = SendResponse{} }
func (m *SendResponse) String() string            { return proto.CompactTextString(m) }
func (*SendResponse) ProtoMessage()               {}
func (*SendResponse) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{4} }

func (m *SendResponse) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *SendResponse) GetMailId() []byte {
	if m != nil {
		return m.MailId
	}
	return nil
}

type BroadcastRequest struct {
	Header *MailHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Body   *MailBody   `protobuf:"bytes,2,opt,name=body" json:"body,omitempty"`
}

func (m *BroadcastRequest) Reset()                    { *m = BroadcastRequest{} }
func (m *BroadcastRequest) String() string            { return proto.CompactTextString(m) }
func (*BroadcastRequest) ProtoMessage()               {}
func (*BroadcastRequest) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{5} }

func (m *BroadcastRequest) GetHeader() *MailHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *BroadcastRequest) GetBody() *MailBody {
	if m != nil {
		return m.Body
	}
	return nil
}

type BroadcastResponse struct {
	Result *Result `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
	MailId []byte  `protobuf:"bytes,3,opt,name=mail_id,json=mailId,proto3" json:"mail_id,omitempty"`
}

func (m *BroadcastResponse) Reset()                    { *m = BroadcastResponse{} }
func (m *BroadcastResponse) String() string            { return proto.CompactTextString(m) }
func (*BroadcastResponse) ProtoMessage()               {}
func (*BroadcastResponse) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{6} }

func (m *BroadcastResponse) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *BroadcastResponse) GetMailId() []byte {
	if m != nil {
		return m.MailId
	}
	return nil
}

type GetMailCountRequest struct {
	To []byte `protobuf:"bytes,1,opt,name=to,proto3" json:"to,omitempty"`
	// 开始时间，unix time() 值。对于系统广播邮件，需要设置时间以去除建号以前的邮件。
	FromTime int64 `protobuf:"varint,2,opt,name=from_time,json=fromTime,proto3" json:"from_time,omitempty"`
}

func (m *GetMailCountRequest) Reset()                    { *m = GetMailCountRequest{} }
func (m *GetMailCountRequest) String() string            { return proto.CompactTextString(m) }
func (*GetMailCountRequest) ProtoMessage()               {}
func (*GetMailCountRequest) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{7} }

func (m *GetMailCountRequest) GetTo() []byte {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *GetMailCountRequest) GetFromTime() int64 {
	if m != nil {
		return m.FromTime
	}
	return 0
}

type GetMailCountResponse struct {
	Result *Result `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
	// 因为 total 和 read 是分别查询的，所以不一定 total >= read。
	Total uint32 `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
	Read  uint32 `protobuf:"varint,3,opt,name=read,proto3" json:"read,omitempty"`
}

func (m *GetMailCountResponse) Reset()                    { *m = GetMailCountResponse{} }
func (m *GetMailCountResponse) String() string            { return proto.CompactTextString(m) }
func (*GetMailCountResponse) ProtoMessage()               {}
func (*GetMailCountResponse) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{8} }

func (m *GetMailCountResponse) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *GetMailCountResponse) GetTotal() uint32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *GetMailCountResponse) GetRead() uint32 {
	if m != nil {
		return m.Read
	}
	return 0
}

type ListRequest struct {
	// 全服邮件和用户邮件是2个不同的列表。
	IsBroadcast bool   `protobuf:"varint,6,opt,name=is_broadcast,json=isBroadcast,proto3" json:"is_broadcast,omitempty"`
	To          []byte `protobuf:"bytes,1,opt,name=to,proto3" json:"to,omitempty"`
	// 邮件按发送时间排序. 时间相同则按邮件ID排序.
	// 默认查询最新邮件，列出 [start, end) 区间内的邮件，start 一般为空。
	// 如果 ascend = true, 即从最早的邮件开始查询，则列出 (start, end] 区间内的邮件, end 一般为空。
	// 分页列举时，首次查询可以让 start,end 都为空，
	//    如果返回个数等于 limit, 说明需要下一页查询。
	//    如果 ascend = false, 则将 end 设为上一页的最早一封邮件的时间和ID, start为空, 再次查询;
	//    如果 ascend = true，则将 start 设为上一页的最晚一封邮件的时间和ID, end为空，再次查询。
	//    如果返回个数小于 limit, 说明已查询完成所有分页。
	Start *ListRequest_TimeAndID `protobuf:"bytes,2,opt,name=start" json:"start,omitempty"`
	End   *ListRequest_TimeAndID `protobuf:"bytes,3,opt,name=end" json:"end,omitempty"`
	Limit uint32                 `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	// 缺省接降序排列，即先列出最新的邮件。
	// 如果需要从最早的邮件开始列，则需要升序排列。
	Ascend bool `protobuf:"varint,5,opt,name=ascend,proto3" json:"ascend,omitempty"`
}

func (m *ListRequest) Reset()                    { *m = ListRequest{} }
func (m *ListRequest) String() string            { return proto.CompactTextString(m) }
func (*ListRequest) ProtoMessage()               {}
func (*ListRequest) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{9} }

func (m *ListRequest) GetIsBroadcast() bool {
	if m != nil {
		return m.IsBroadcast
	}
	return false
}

func (m *ListRequest) GetTo() []byte {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *ListRequest) GetStart() *ListRequest_TimeAndID {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *ListRequest) GetEnd() *ListRequest_TimeAndID {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *ListRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListRequest) GetAscend() bool {
	if m != nil {
		return m.Ascend
	}
	return false
}

// 邮件按 (发送时间, 邮件ID) 排序
type ListRequest_TimeAndID struct {
	Time   int64  `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	MailId []byte `protobuf:"bytes,2,opt,name=mail_id,json=mailId,proto3" json:"mail_id,omitempty"`
}

func (m *ListRequest_TimeAndID) Reset()                    { *m = ListRequest_TimeAndID{} }
func (m *ListRequest_TimeAndID) String() string            { return proto.CompactTextString(m) }
func (*ListRequest_TimeAndID) ProtoMessage()               {}
func (*ListRequest_TimeAndID) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{9, 0} }

func (m *ListRequest_TimeAndID) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *ListRequest_TimeAndID) GetMailId() []byte {
	if m != nil {
		return m.MailId
	}
	return nil
}

type MailHeaderWithID struct {
	MailId []byte      `protobuf:"bytes,1,opt,name=mail_id,json=mailId,proto3" json:"mail_id,omitempty"`
	Header *MailHeader `protobuf:"bytes,2,opt,name=header" json:"header,omitempty"`
}

func (m *MailHeaderWithID) Reset()                    { *m = MailHeaderWithID{} }
func (m *MailHeaderWithID) String() string            { return proto.CompactTextString(m) }
func (*MailHeaderWithID) ProtoMessage()               {}
func (*MailHeaderWithID) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{10} }

func (m *MailHeaderWithID) GetMailId() []byte {
	if m != nil {
		return m.MailId
	}
	return nil
}

func (m *MailHeaderWithID) GetHeader() *MailHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type ListResponse struct {
	Result *Result             `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
	Mails  []*MailHeaderWithID `protobuf:"bytes,2,rep,name=mails" json:"mails,omitempty"`
}

func (m *ListResponse) Reset()                    { *m = ListResponse{} }
func (m *ListResponse) String() string            { return proto.CompactTextString(m) }
func (*ListResponse) ProtoMessage()               {}
func (*ListResponse) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{11} }

func (m *ListResponse) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *ListResponse) GetMails() []*MailHeaderWithID {
	if m != nil {
		return m.Mails
	}
	return nil
}

// 邮件索引
type MailIndex struct {
	To          []byte `protobuf:"bytes,1,opt,name=to,proto3" json:"to,omitempty"`
	IsBroadcast bool   `protobuf:"varint,2,opt,name=is_broadcast,json=isBroadcast,proto3" json:"is_broadcast,omitempty"`
	MailId      []byte `protobuf:"bytes,3,opt,name=mail_id,json=mailId,proto3" json:"mail_id,omitempty"`
}

func (m *MailIndex) Reset()                    { *m = MailIndex{} }
func (m *MailIndex) String() string            { return proto.CompactTextString(m) }
func (*MailIndex) ProtoMessage()               {}
func (*MailIndex) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{12} }

func (m *MailIndex) GetTo() []byte {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *MailIndex) GetIsBroadcast() bool {
	if m != nil {
		return m.IsBroadcast
	}
	return false
}

func (m *MailIndex) GetMailId() []byte {
	if m != nil {
		return m.MailId
	}
	return nil
}

type GetRequest struct {
	MailIndex *MailIndex `protobuf:"bytes,1,opt,name=mail_index,json=mailIndex" json:"mail_index,omitempty"`
}

func (m *GetRequest) Reset()                    { *m = GetRequest{} }
func (m *GetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()               {}
func (*GetRequest) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{13} }

func (m *GetRequest) GetMailIndex() *MailIndex {
	if m != nil {
		return m.MailIndex
	}
	return nil
}

type GetResponse struct {
	Result *Result   `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
	Body   *MailBody `protobuf:"bytes,2,opt,name=body" json:"body,omitempty"`
}

func (m *GetResponse) Reset()                    { *m = GetResponse{} }
func (m *GetResponse) String() string            { return proto.CompactTextString(m) }
func (*GetResponse) ProtoMessage()               {}
func (*GetResponse) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{14} }

func (m *GetResponse) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *GetResponse) GetBody() *MailBody {
	if m != nil {
		return m.Body
	}
	return nil
}

type DeleteRequest struct {
	MailIndex *MailIndex `protobuf:"bytes,1,opt,name=mail_index,json=mailIndex" json:"mail_index,omitempty"`
}

func (m *DeleteRequest) Reset()                    { *m = DeleteRequest{} }
func (m *DeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteRequest) ProtoMessage()               {}
func (*DeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{15} }

func (m *DeleteRequest) GetMailIndex() *MailIndex {
	if m != nil {
		return m.MailIndex
	}
	return nil
}

type DeleteResponse struct {
	Result *Result `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
}

func (m *DeleteResponse) Reset()                    { *m = DeleteResponse{} }
func (m *DeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteResponse) ProtoMessage()               {}
func (*DeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{16} }

func (m *DeleteResponse) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

type MarkAsReadRequest struct {
	MailIndex *MailIndex `protobuf:"bytes,1,opt,name=mail_index,json=mailIndex" json:"mail_index,omitempty"`
}

func (m *MarkAsReadRequest) Reset()                    { *m = MarkAsReadRequest{} }
func (m *MarkAsReadRequest) String() string            { return proto.CompactTextString(m) }
func (*MarkAsReadRequest) ProtoMessage()               {}
func (*MarkAsReadRequest) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{17} }

func (m *MarkAsReadRequest) GetMailIndex() *MailIndex {
	if m != nil {
		return m.MailIndex
	}
	return nil
}

type MarkAsReadResponse struct {
	Result *Result `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
}

func (m *MarkAsReadResponse) Reset()                    { *m = MarkAsReadResponse{} }
func (m *MarkAsReadResponse) String() string            { return proto.CompactTextString(m) }
func (*MarkAsReadResponse) ProtoMessage()               {}
func (*MarkAsReadResponse) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{18} }

func (m *MarkAsReadResponse) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

type MarkAsUnreadRequest struct {
	MailIndex *MailIndex `protobuf:"bytes,1,opt,name=mail_index,json=mailIndex" json:"mail_index,omitempty"`
}

func (m *MarkAsUnreadRequest) Reset()                    { *m = MarkAsUnreadRequest{} }
func (m *MarkAsUnreadRequest) String() string            { return proto.CompactTextString(m) }
func (*MarkAsUnreadRequest) ProtoMessage()               {}
func (*MarkAsUnreadRequest) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{19} }

func (m *MarkAsUnreadRequest) GetMailIndex() *MailIndex {
	if m != nil {
		return m.MailIndex
	}
	return nil
}

type MarkAsUnreadResponse struct {
	Result *Result `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
}

func (m *MarkAsUnreadResponse) Reset()                    { *m = MarkAsUnreadResponse{} }
func (m *MarkAsUnreadResponse) String() string            { return proto.CompactTextString(m) }
func (*MarkAsUnreadResponse) ProtoMessage()               {}
func (*MarkAsUnreadResponse) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{20} }

func (m *MarkAsUnreadResponse) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

type MarkAttachmentsAsReceivedRequest struct {
	MailIndex *MailIndex `protobuf:"bytes,1,opt,name=mail_index,json=mailIndex" json:"mail_index,omitempty"`
}

func (m *MarkAttachmentsAsReceivedRequest) Reset()         { *m = MarkAttachmentsAsReceivedRequest{} }
func (m *MarkAttachmentsAsReceivedRequest) String() string { return proto.CompactTextString(m) }
func (*MarkAttachmentsAsReceivedRequest) ProtoMessage()    {}
func (*MarkAttachmentsAsReceivedRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorMail, []int{21}
}

func (m *MarkAttachmentsAsReceivedRequest) GetMailIndex() *MailIndex {
	if m != nil {
		return m.MailIndex
	}
	return nil
}

type MarkAttachmentsAsReceivedResponse struct {
	Result      *Result `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
	CheckFailed bool    `protobuf:"varint,2,opt,name=check_failed,json=checkFailed,proto3" json:"check_failed,omitempty"`
}

func (m *MarkAttachmentsAsReceivedResponse) Reset()         { *m = MarkAttachmentsAsReceivedResponse{} }
func (m *MarkAttachmentsAsReceivedResponse) String() string { return proto.CompactTextString(m) }
func (*MarkAttachmentsAsReceivedResponse) ProtoMessage()    {}
func (*MarkAttachmentsAsReceivedResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorMail, []int{22}
}

func (m *MarkAttachmentsAsReceivedResponse) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *MarkAttachmentsAsReceivedResponse) GetCheckFailed() bool {
	if m != nil {
		return m.CheckFailed
	}
	return false
}

type SetCustomDataRequest struct {
	MailIndex  *MailIndex `protobuf:"bytes,1,opt,name=mail_index,json=mailIndex" json:"mail_index,omitempty"`
	CustomData []byte     `protobuf:"bytes,2,opt,name=custom_data,json=customData,proto3" json:"custom_data,omitempty"`
}

func (m *SetCustomDataRequest) Reset()                    { *m = SetCustomDataRequest{} }
func (m *SetCustomDataRequest) String() string            { return proto.CompactTextString(m) }
func (*SetCustomDataRequest) ProtoMessage()               {}
func (*SetCustomDataRequest) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{23} }

func (m *SetCustomDataRequest) GetMailIndex() *MailIndex {
	if m != nil {
		return m.MailIndex
	}
	return nil
}

func (m *SetCustomDataRequest) GetCustomData() []byte {
	if m != nil {
		return m.CustomData
	}
	return nil
}

type SetCustomDataResponse struct {
	Result *Result `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
}

func (m *SetCustomDataResponse) Reset()                    { *m = SetCustomDataResponse{} }
func (m *SetCustomDataResponse) String() string            { return proto.CompactTextString(m) }
func (*SetCustomDataResponse) ProtoMessage()               {}
func (*SetCustomDataResponse) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{24} }

func (m *SetCustomDataResponse) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

type SubscribeRequest struct {
	IsSubscribe bool   `protobuf:"varint,1,opt,name=is_subscribe,json=isSubscribe,proto3" json:"is_subscribe,omitempty"`
	To          []byte `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty"`
}

func (m *SubscribeRequest) Reset()                    { *m = SubscribeRequest{} }
func (m *SubscribeRequest) String() string            { return proto.CompactTextString(m) }
func (*SubscribeRequest) ProtoMessage()               {}
func (*SubscribeRequest) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{25} }

func (m *SubscribeRequest) GetIsSubscribe() bool {
	if m != nil {
		return m.IsSubscribe
	}
	return false
}

func (m *SubscribeRequest) GetTo() []byte {
	if m != nil {
		return m.To
	}
	return nil
}

type NewMailNotification struct {
	OBSOLETEIsBroadcast bool `protobuf:"varint,1,opt,name=OBSOLETE_is_broadcast,json=OBSOLETEIsBroadcast,proto3" json:"OBSOLETE_is_broadcast,omitempty"`
	// to_list仅列出非广播邮件的接收人，广播邮件会列出邮件头。
	// 非广播邮件可能量较大，不适合列出邮件头，需要用户再次查询。
	// 而广播邮件都是相同的，不应该每个用户再次各自查询。
	ToList         [][]byte            `protobuf:"bytes,2,rep,name=to_list,json=toList" json:"to_list,omitempty"`
	BroadcastMails []*MailHeaderWithID `protobuf:"bytes,3,rep,name=broadcast_mails,json=broadcastMails" json:"broadcast_mails,omitempty"`
}

func (m *NewMailNotification) Reset()                    { *m = NewMailNotification{} }
func (m *NewMailNotification) String() string            { return proto.CompactTextString(m) }
func (*NewMailNotification) ProtoMessage()               {}
func (*NewMailNotification) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{26} }

func (m *NewMailNotification) GetOBSOLETEIsBroadcast() bool {
	if m != nil {
		return m.OBSOLETEIsBroadcast
	}
	return false
}

func (m *NewMailNotification) GetToList() [][]byte {
	if m != nil {
		return m.ToList
	}
	return nil
}

func (m *NewMailNotification) GetBroadcastMails() []*MailHeaderWithID {
	if m != nil {
		return m.BroadcastMails
	}
	return nil
}

func init() {
	proto.RegisterType((*MailHeader)(nil), "pb.MailHeader")
	proto.RegisterType((*MailHeader_AttachmentBrief)(nil), "pb.MailHeader.AttachmentBrief")
	proto.RegisterType((*MailHeader_Time)(nil), "pb.MailHeader.Time")
	proto.RegisterType((*MailHeader_Status)(nil), "pb.MailHeader.Status")
	proto.RegisterType((*MailBody)(nil), "pb.MailBody")
	proto.RegisterType((*MailBody_AttachmentBody)(nil), "pb.MailBody.AttachmentBody")
	proto.RegisterType((*Result)(nil), "pb.Result")
	proto.RegisterType((*SendRequest)(nil), "pb.SendRequest")
	proto.RegisterType((*SendResponse)(nil), "pb.SendResponse")
	proto.RegisterType((*BroadcastRequest)(nil), "pb.BroadcastRequest")
	proto.RegisterType((*BroadcastResponse)(nil), "pb.BroadcastResponse")
	proto.RegisterType((*GetMailCountRequest)(nil), "pb.GetMailCountRequest")
	proto.RegisterType((*GetMailCountResponse)(nil), "pb.GetMailCountResponse")
	proto.RegisterType((*ListRequest)(nil), "pb.ListRequest")
	proto.RegisterType((*ListRequest_TimeAndID)(nil), "pb.ListRequest.TimeAndID")
	proto.RegisterType((*MailHeaderWithID)(nil), "pb.MailHeaderWithID")
	proto.RegisterType((*ListResponse)(nil), "pb.ListResponse")
	proto.RegisterType((*MailIndex)(nil), "pb.MailIndex")
	proto.RegisterType((*GetRequest)(nil), "pb.GetRequest")
	proto.RegisterType((*GetResponse)(nil), "pb.GetResponse")
	proto.RegisterType((*DeleteRequest)(nil), "pb.DeleteRequest")
	proto.RegisterType((*DeleteResponse)(nil), "pb.DeleteResponse")
	proto.RegisterType((*MarkAsReadRequest)(nil), "pb.MarkAsReadRequest")
	proto.RegisterType((*MarkAsReadResponse)(nil), "pb.MarkAsReadResponse")
	proto.RegisterType((*MarkAsUnreadRequest)(nil), "pb.MarkAsUnreadRequest")
	proto.RegisterType((*MarkAsUnreadResponse)(nil), "pb.MarkAsUnreadResponse")
	proto.RegisterType((*MarkAttachmentsAsReceivedRequest)(nil), "pb.MarkAttachmentsAsReceivedRequest")
	proto.RegisterType((*MarkAttachmentsAsReceivedResponse)(nil), "pb.MarkAttachmentsAsReceivedResponse")
	proto.RegisterType((*SetCustomDataRequest)(nil), "pb.SetCustomDataRequest")
	proto.RegisterType((*SetCustomDataResponse)(nil), "pb.SetCustomDataResponse")
	proto.RegisterType((*SubscribeRequest)(nil), "pb.SubscribeRequest")
	proto.RegisterType((*NewMailNotification)(nil), "pb.NewMailNotification")
}

var _insEmptyMailClient EmptyMailClient

type EmptyMailClient struct {
}

func (client *EmptyMailClient) Send(ctx context.Context, in *SendRequest, opts ...grpc.CallOption) (*SendResponse, error) {
	out := new(SendResponse)
	return out, errors.New("Use Empty Client")
}

func (client *EmptyMailClient) Broadcast(ctx context.Context, in *BroadcastRequest, opts ...grpc.CallOption) (*BroadcastResponse, error) {
	out := new(BroadcastResponse)
	return out, errors.New("Use Empty Client")
}

func (client *EmptyMailClient) GetMailCount(ctx context.Context, in *GetMailCountRequest, opts ...grpc.CallOption) (*GetMailCountResponse, error) {
	out := new(GetMailCountResponse)
	return out, errors.New("Use Empty Client")
}

func (client *EmptyMailClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error) {
	out := new(ListResponse)
	return out, errors.New("Use Empty Client")
}

func (client *EmptyMailClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	return out, errors.New("Use Empty Client")
}

func (client *EmptyMailClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	out := new(DeleteResponse)
	return out, errors.New("Use Empty Client")
}

func (client *EmptyMailClient) MarkAsRead(ctx context.Context, in *MarkAsReadRequest, opts ...grpc.CallOption) (*MarkAsReadResponse, error) {
	out := new(MarkAsReadResponse)
	return out, errors.New("Use Empty Client")
}

func (client *EmptyMailClient) MarkAsUnread(ctx context.Context, in *MarkAsUnreadRequest, opts ...grpc.CallOption) (*MarkAsUnreadResponse, error) {
	out := new(MarkAsUnreadResponse)
	return out, errors.New("Use Empty Client")
}

func (client *EmptyMailClient) MarkAttachmentsAsReceived(ctx context.Context, in *MarkAttachmentsAsReceivedRequest, opts ...grpc.CallOption) (*MarkAttachmentsAsReceivedResponse, error) {
	out := new(MarkAttachmentsAsReceivedResponse)
	return out, errors.New("Use Empty Client")
}

func (client *EmptyMailClient) SetCustomData(ctx context.Context, in *SetCustomDataRequest, opts ...grpc.CallOption) (*SetCustomDataResponse, error) {
	out := new(SetCustomDataResponse)
	return out, errors.New("Use Empty Client")
}

func (client *EmptyMailClient) GetNewMailNotifications(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*NewMailNotification, error) {
	out := new(NewMailNotification)
	return out, errors.New("Use Empty Client")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Mail service

type MailClient interface {
	// 发邮件
	Send(ctx context.Context, in *SendRequest, opts ...grpc.CallOption) (*SendResponse, error)
	// 发全服邮件.
	Broadcast(ctx context.Context, in *BroadcastRequest, opts ...grpc.CallOption) (*BroadcastResponse, error)
	// 查询邮件数和已读邮件数
	GetMailCount(ctx context.Context, in *GetMailCountRequest, opts ...grpc.CallOption) (*GetMailCountResponse, error)
	// 查询邮件列表
	List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error)
	// 查询一封邮件的内容
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
	// 删除一封邮件
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	// 标记邮件已读/未读
	MarkAsRead(ctx context.Context, in *MarkAsReadRequest, opts ...grpc.CallOption) (*MarkAsReadResponse, error)
	MarkAsUnread(ctx context.Context, in *MarkAsUnreadRequest, opts ...grpc.CallOption) (*MarkAsUnreadResponse, error)
	// 标记附件已领取，只有在未领取状态下才会成功
	MarkAttachmentsAsReceived(ctx context.Context, in *MarkAttachmentsAsReceivedRequest, opts ...grpc.CallOption) (*MarkAttachmentsAsReceivedResponse, error)
	// 设置邮件自定义数据. 可保存任意数据, 例如阅读进度，标签.
	SetCustomData(ctx context.Context, in *SetCustomDataRequest, opts ...grpc.CallOption) (*SetCustomDataResponse, error)
	// 获取新邮件通知
	GetNewMailNotifications(ctx context.Context, opts ...grpc.CallOption) (Mail_GetNewMailNotificationsClient, error)
}

type mailClient struct {
	cc *grpc.ClientConn
}

func NewMailClient(cc *grpc.ClientConn) MailClient {
	return &mailClient{cc}
}

func (c *mailClient) Send(ctx context.Context, in *SendRequest, opts ...grpc.CallOption) (*SendResponse, error) {
	out := new(SendResponse)
	err := grpc.Invoke(ctx, "/pb.Mail/Send", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) Broadcast(ctx context.Context, in *BroadcastRequest, opts ...grpc.CallOption) (*BroadcastResponse, error) {
	out := new(BroadcastResponse)
	err := grpc.Invoke(ctx, "/pb.Mail/Broadcast", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) GetMailCount(ctx context.Context, in *GetMailCountRequest, opts ...grpc.CallOption) (*GetMailCountResponse, error) {
	out := new(GetMailCountResponse)
	err := grpc.Invoke(ctx, "/pb.Mail/GetMailCount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error) {
	out := new(ListResponse)
	err := grpc.Invoke(ctx, "/pb.Mail/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := grpc.Invoke(ctx, "/pb.Mail/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	out := new(DeleteResponse)
	err := grpc.Invoke(ctx, "/pb.Mail/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) MarkAsRead(ctx context.Context, in *MarkAsReadRequest, opts ...grpc.CallOption) (*MarkAsReadResponse, error) {
	out := new(MarkAsReadResponse)
	err := grpc.Invoke(ctx, "/pb.Mail/MarkAsRead", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) MarkAsUnread(ctx context.Context, in *MarkAsUnreadRequest, opts ...grpc.CallOption) (*MarkAsUnreadResponse, error) {
	out := new(MarkAsUnreadResponse)
	err := grpc.Invoke(ctx, "/pb.Mail/MarkAsUnread", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) MarkAttachmentsAsReceived(ctx context.Context, in *MarkAttachmentsAsReceivedRequest, opts ...grpc.CallOption) (*MarkAttachmentsAsReceivedResponse, error) {
	out := new(MarkAttachmentsAsReceivedResponse)
	err := grpc.Invoke(ctx, "/pb.Mail/MarkAttachmentsAsReceived", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) SetCustomData(ctx context.Context, in *SetCustomDataRequest, opts ...grpc.CallOption) (*SetCustomDataResponse, error) {
	out := new(SetCustomDataResponse)
	err := grpc.Invoke(ctx, "/pb.Mail/SetCustomData", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) GetNewMailNotifications(ctx context.Context, opts ...grpc.CallOption) (Mail_GetNewMailNotificationsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Mail_serviceDesc.Streams[0], c.cc, "/pb.Mail/GetNewMailNotifications", opts...)
	if err != nil {
		return nil, err
	}
	x := &mailGetNewMailNotificationsClient{stream}
	return x, nil
}

type Mail_GetNewMailNotificationsClient interface {
	Send(*SubscribeRequest) error
	Recv() (*NewMailNotification, error)
	grpc.ClientStream
}

type mailGetNewMailNotificationsClient struct {
	grpc.ClientStream
}

func (x *mailGetNewMailNotificationsClient) Send(m *SubscribeRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *mailGetNewMailNotificationsClient) Recv() (*NewMailNotification, error) {
	m := new(NewMailNotification)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Mail service

type MailServer interface {
	// 发邮件
	Send(context.Context, *SendRequest) (*SendResponse, error)
	// 发全服邮件.
	Broadcast(context.Context, *BroadcastRequest) (*BroadcastResponse, error)
	// 查询邮件数和已读邮件数
	GetMailCount(context.Context, *GetMailCountRequest) (*GetMailCountResponse, error)
	// 查询邮件列表
	List(context.Context, *ListRequest) (*ListResponse, error)
	// 查询一封邮件的内容
	Get(context.Context, *GetRequest) (*GetResponse, error)
	// 删除一封邮件
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
	// 标记邮件已读/未读
	MarkAsRead(context.Context, *MarkAsReadRequest) (*MarkAsReadResponse, error)
	MarkAsUnread(context.Context, *MarkAsUnreadRequest) (*MarkAsUnreadResponse, error)
	// 标记附件已领取，只有在未领取状态下才会成功
	MarkAttachmentsAsReceived(context.Context, *MarkAttachmentsAsReceivedRequest) (*MarkAttachmentsAsReceivedResponse, error)
	// 设置邮件自定义数据. 可保存任意数据, 例如阅读进度，标签.
	SetCustomData(context.Context, *SetCustomDataRequest) (*SetCustomDataResponse, error)
	// 获取新邮件通知
	GetNewMailNotifications(Mail_GetNewMailNotificationsServer) error
	PanicHandle(interface{}, interface{})
}

func RegisterMailServer(s *grpc.Server, srv MailServer) {
	s.RegisterService(&_Mail_serviceDesc, srv)
}

func _Mail_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Mail/Send",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).Send(ctx, req.(*SendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_Broadcast_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BroadcastRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).Broadcast(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Mail/Broadcast",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).Broadcast(ctx, req.(*BroadcastRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_GetMailCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMailCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).GetMailCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Mail/GetMailCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).GetMailCount(ctx, req.(*GetMailCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Mail/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).List(ctx, req.(*ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Mail/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Mail/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).Delete(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_MarkAsRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkAsReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).MarkAsRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Mail/MarkAsRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).MarkAsRead(ctx, req.(*MarkAsReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_MarkAsUnread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkAsUnreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).MarkAsUnread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Mail/MarkAsUnread",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).MarkAsUnread(ctx, req.(*MarkAsUnreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_MarkAttachmentsAsReceived_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkAttachmentsAsReceivedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).MarkAttachmentsAsReceived(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Mail/MarkAttachmentsAsReceived",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).MarkAttachmentsAsReceived(ctx, req.(*MarkAttachmentsAsReceivedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_SetCustomData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCustomDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).SetCustomData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Mail/SetCustomData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).SetCustomData(ctx, req.(*SetCustomDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_GetNewMailNotifications_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MailServer).GetNewMailNotifications(&mailGetNewMailNotificationsServer{stream})
}

type Mail_GetNewMailNotificationsServer interface {
	Send(*NewMailNotification) error
	Recv() (*SubscribeRequest, error)
	grpc.ServerStream
}

type mailGetNewMailNotificationsServer struct {
	grpc.ServerStream
}

func (x *mailGetNewMailNotificationsServer) Send(m *NewMailNotification) error {
	return x.ServerStream.SendMsg(m)
}

func (x *mailGetNewMailNotificationsServer) Recv() (*SubscribeRequest, error) {
	m := new(SubscribeRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Mail_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Mail",
	HandlerType: (*MailServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _Mail_Send_Handler,
		},
		{
			MethodName: "Broadcast",
			Handler:    _Mail_Broadcast_Handler,
		},
		{
			MethodName: "GetMailCount",
			Handler:    _Mail_GetMailCount_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Mail_List_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Mail_Get_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Mail_Delete_Handler,
		},
		{
			MethodName: "MarkAsRead",
			Handler:    _Mail_MarkAsRead_Handler,
		},
		{
			MethodName: "MarkAsUnread",
			Handler:    _Mail_MarkAsUnread_Handler,
		},
		{
			MethodName: "MarkAttachmentsAsReceived",
			Handler:    _Mail_MarkAttachmentsAsReceived_Handler,
		},
		{
			MethodName: "SetCustomData",
			Handler:    _Mail_SetCustomData_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetNewMailNotifications",
			Handler:       _Mail_GetNewMailNotifications_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "mail.proto",
}

func (m *MailHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.From) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.From)))
		i += copy(dAtA[i:], m.From)
	}
	if len(m.FromNick) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.FromNick)))
		i += copy(dAtA[i:], m.FromNick)
	}
	if len(m.To) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.To)))
		i += copy(dAtA[i:], m.To)
	}
	if len(m.ToNick) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.ToNick)))
		i += copy(dAtA[i:], m.ToNick)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Brief) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Brief)))
		i += copy(dAtA[i:], m.Brief)
	}
	if m.BodyLen != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.BodyLen))
	}
	if len(m.Attachments) > 0 {
		for _, msg := range m.Attachments {
			dAtA[i] = 0x42
			i++
			i = encodeVarintMail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Time != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Time.Size()))
		n1, err := m.Time.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Status != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Status.Size()))
		n2, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *MailHeader_AttachmentBrief) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailHeader_AttachmentBrief) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Index))
	}
	if len(m.Brief) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Brief)))
		i += copy(dAtA[i:], m.Brief)
	}
	if len(m.Item) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Item)))
		i += copy(dAtA[i:], m.Item)
	}
	if m.Count != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Count))
	}
	if m.ItemId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.ItemId))
	}
	return i, nil
}

func (m *MailHeader_Time) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailHeader_Time) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Send != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Send))
	}
	if m.Expire != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Expire))
	}
	return i, nil
}

func (m *MailHeader_Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailHeader_Status) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Read {
		dAtA[i] = 0x8
		i++
		if m.Read {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AttachmentsReceived {
		dAtA[i] = 0x10
		i++
		if m.AttachmentsReceived {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.CustomData) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.CustomData)))
		i += copy(dAtA[i:], m.CustomData)
	}
	return i, nil
}

func (m *MailBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailBody) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Body) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if len(m.Attachments) > 0 {
		for _, msg := range m.Attachments {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MailBody_AttachmentBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailBody_AttachmentBody) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Index))
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	return i, nil
}

func (m *Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Result) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ok {
		dAtA[i] = 0x8
		i++
		if m.Ok {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *SendRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Header.Size()))
		n3, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Body != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Body.Size()))
		n4, err := m.Body.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *SendResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Result.Size()))
		n5, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.MailId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.MailId)))
		i += copy(dAtA[i:], m.MailId)
	}
	return i, nil
}

func (m *BroadcastRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BroadcastRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Header.Size()))
		n6, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Body != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Body.Size()))
		n7, err := m.Body.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *BroadcastResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BroadcastResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Result.Size()))
		n8, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.MailId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.MailId)))
		i += copy(dAtA[i:], m.MailId)
	}
	return i, nil
}

func (m *GetMailCountRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMailCountRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.To) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.To)))
		i += copy(dAtA[i:], m.To)
	}
	if m.FromTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.FromTime))
	}
	return i, nil
}

func (m *GetMailCountResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMailCountResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Result.Size()))
		n9, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Total != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Total))
	}
	if m.Read != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Read))
	}
	return i, nil
}

func (m *ListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.To) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.To)))
		i += copy(dAtA[i:], m.To)
	}
	if m.Start != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Start.Size()))
		n10, err := m.Start.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.End != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.End.Size()))
		n11, err := m.End.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Limit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Limit))
	}
	if m.Ascend {
		dAtA[i] = 0x28
		i++
		if m.Ascend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsBroadcast {
		dAtA[i] = 0x30
		i++
		if m.IsBroadcast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ListRequest_TimeAndID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRequest_TimeAndID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Time))
	}
	if len(m.MailId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.MailId)))
		i += copy(dAtA[i:], m.MailId)
	}
	return i, nil
}

func (m *MailHeaderWithID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailHeaderWithID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MailId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.MailId)))
		i += copy(dAtA[i:], m.MailId)
	}
	if m.Header != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Header.Size()))
		n12, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *ListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Result.Size()))
		n13, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.Mails) > 0 {
		for _, msg := range m.Mails {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MailIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailIndex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.To) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.To)))
		i += copy(dAtA[i:], m.To)
	}
	if m.IsBroadcast {
		dAtA[i] = 0x10
		i++
		if m.IsBroadcast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.MailId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.MailId)))
		i += copy(dAtA[i:], m.MailId)
	}
	return i, nil
}

func (m *GetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MailIndex != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.MailIndex.Size()))
		n14, err := m.MailIndex.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *GetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Result.Size()))
		n15, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Body != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Body.Size()))
		n16, err := m.Body.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *DeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MailIndex != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.MailIndex.Size()))
		n17, err := m.MailIndex.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *DeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Result.Size()))
		n18, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *MarkAsReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkAsReadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MailIndex != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.MailIndex.Size()))
		n19, err := m.MailIndex.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *MarkAsReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkAsReadResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Result.Size()))
		n20, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *MarkAsUnreadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkAsUnreadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MailIndex != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.MailIndex.Size()))
		n21, err := m.MailIndex.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *MarkAsUnreadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkAsUnreadResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Result.Size()))
		n22, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *MarkAttachmentsAsReceivedRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkAttachmentsAsReceivedRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MailIndex != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.MailIndex.Size()))
		n23, err := m.MailIndex.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *MarkAttachmentsAsReceivedResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkAttachmentsAsReceivedResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Result.Size()))
		n24, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.CheckFailed {
		dAtA[i] = 0x10
		i++
		if m.CheckFailed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SetCustomDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetCustomDataRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MailIndex != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.MailIndex.Size()))
		n25, err := m.MailIndex.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if len(m.CustomData) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.CustomData)))
		i += copy(dAtA[i:], m.CustomData)
	}
	return i, nil
}

func (m *SetCustomDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetCustomDataResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Result.Size()))
		n26, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *SubscribeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsSubscribe {
		dAtA[i] = 0x8
		i++
		if m.IsSubscribe {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.To) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.To)))
		i += copy(dAtA[i:], m.To)
	}
	return i, nil
}

func (m *NewMailNotification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewMailNotification) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OBSOLETEIsBroadcast {
		dAtA[i] = 0x8
		i++
		if m.OBSOLETEIsBroadcast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ToList) > 0 {
		for _, b := range m.ToList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMail(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.BroadcastMails) > 0 {
		for _, msg := range m.BroadcastMails {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Mail(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Mail(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintMail(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MailHeader) Size() (n int) {
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.FromNick)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.ToNick)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.Brief)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	if m.BodyLen != 0 {
		n += 1 + sovMail(uint64(m.BodyLen))
	}
	if len(m.Attachments) > 0 {
		for _, e := range m.Attachments {
			l = e.Size()
			n += 1 + l + sovMail(uint64(l))
		}
	}
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *MailHeader_AttachmentBrief) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovMail(uint64(m.Index))
	}
	l = len(m.Brief)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.Item)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovMail(uint64(m.Count))
	}
	if m.ItemId != 0 {
		n += 1 + sovMail(uint64(m.ItemId))
	}
	return n
}

func (m *MailHeader_Time) Size() (n int) {
	var l int
	_ = l
	if m.Send != 0 {
		n += 1 + sovMail(uint64(m.Send))
	}
	if m.Expire != 0 {
		n += 1 + sovMail(uint64(m.Expire))
	}
	return n
}

func (m *MailHeader_Status) Size() (n int) {
	var l int
	_ = l
	if m.Read {
		n += 2
	}
	if m.AttachmentsReceived {
		n += 2
	}
	l = len(m.CustomData)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *MailBody) Size() (n int) {
	var l int
	_ = l
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	if len(m.Attachments) > 0 {
		for _, e := range m.Attachments {
			l = e.Size()
			n += 1 + l + sovMail(uint64(l))
		}
	}
	return n
}

func (m *MailBody_AttachmentBody) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovMail(uint64(m.Index))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *Result) Size() (n int) {
	var l int
	_ = l
	if m.Ok {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *SendRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *SendResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.MailId)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *BroadcastRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *BroadcastResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.MailId)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *GetMailCountRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	if m.FromTime != 0 {
		n += 1 + sovMail(uint64(m.FromTime))
	}
	return n
}

func (m *GetMailCountResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if m.Total != 0 {
		n += 1 + sovMail(uint64(m.Total))
	}
	if m.Read != 0 {
		n += 1 + sovMail(uint64(m.Read))
	}
	return n
}

func (m *ListRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovMail(uint64(m.Limit))
	}
	if m.Ascend {
		n += 2
	}
	if m.IsBroadcast {
		n += 2
	}
	return n
}

func (m *ListRequest_TimeAndID) Size() (n int) {
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovMail(uint64(m.Time))
	}
	l = len(m.MailId)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *MailHeaderWithID) Size() (n int) {
	var l int
	_ = l
	l = len(m.MailId)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *ListResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if len(m.Mails) > 0 {
		for _, e := range m.Mails {
			l = e.Size()
			n += 1 + l + sovMail(uint64(l))
		}
	}
	return n
}

func (m *MailIndex) Size() (n int) {
	var l int
	_ = l
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	if m.IsBroadcast {
		n += 2
	}
	l = len(m.MailId)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *GetRequest) Size() (n int) {
	var l int
	_ = l
	if m.MailIndex != nil {
		l = m.MailIndex.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *GetResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *DeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.MailIndex != nil {
		l = m.MailIndex.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *DeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *MarkAsReadRequest) Size() (n int) {
	var l int
	_ = l
	if m.MailIndex != nil {
		l = m.MailIndex.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *MarkAsReadResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *MarkAsUnreadRequest) Size() (n int) {
	var l int
	_ = l
	if m.MailIndex != nil {
		l = m.MailIndex.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *MarkAsUnreadResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *MarkAttachmentsAsReceivedRequest) Size() (n int) {
	var l int
	_ = l
	if m.MailIndex != nil {
		l = m.MailIndex.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *MarkAttachmentsAsReceivedResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if m.CheckFailed {
		n += 2
	}
	return n
}

func (m *SetCustomDataRequest) Size() (n int) {
	var l int
	_ = l
	if m.MailIndex != nil {
		l = m.MailIndex.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.CustomData)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *SetCustomDataResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *SubscribeRequest) Size() (n int) {
	var l int
	_ = l
	if m.IsSubscribe {
		n += 2
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *NewMailNotification) Size() (n int) {
	var l int
	_ = l
	if m.OBSOLETEIsBroadcast {
		n += 2
	}
	if len(m.ToList) > 0 {
		for _, b := range m.ToList {
			l = len(b)
			n += 1 + l + sovMail(uint64(l))
		}
	}
	if len(m.BroadcastMails) > 0 {
		for _, e := range m.BroadcastMails {
			l = e.Size()
			n += 1 + l + sovMail(uint64(l))
		}
	}
	return n
}

func sovMail(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMail(x uint64) (n int) {
	return sovMail(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MailHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = append(m.From[:0], dAtA[iNdEx:postIndex]...)
			if m.From == nil {
				m.From = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromNick", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromNick = append(m.FromNick[:0], dAtA[iNdEx:postIndex]...)
			if m.FromNick == nil {
				m.FromNick = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = append(m.To[:0], dAtA[iNdEx:postIndex]...)
			if m.To == nil {
				m.To = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToNick", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToNick = append(m.ToNick[:0], dAtA[iNdEx:postIndex]...)
			if m.ToNick == nil {
				m.ToNick = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = append(m.Title[:0], dAtA[iNdEx:postIndex]...)
			if m.Title == nil {
				m.Title = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Brief", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Brief = append(m.Brief[:0], dAtA[iNdEx:postIndex]...)
			if m.Brief == nil {
				m.Brief = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyLen", wireType)
			}
			m.BodyLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BodyLen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attachments = append(m.Attachments, &MailHeader_AttachmentBrief{})
			if err := m.Attachments[len(m.Attachments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &MailHeader_Time{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &MailHeader_Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailHeader_AttachmentBrief) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttachmentBrief: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttachmentBrief: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Brief", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Brief = append(m.Brief[:0], dAtA[iNdEx:postIndex]...)
			if m.Brief == nil {
				m.Brief = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field News", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Item = append(m.Item[:0], dAtA[iNdEx:postIndex]...)
			if m.Item == nil {
				m.Item = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailHeader_Time) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Time: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Time: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Send", wireType)
			}
			m.Send = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Send |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailHeader_Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Read", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Read = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachmentsReceived", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AttachmentsReceived = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = append(m.CustomData[:0], dAtA[iNdEx:postIndex]...)
			if m.CustomData == nil {
				m.CustomData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attachments = append(m.Attachments, &MailBody_AttachmentBody{})
			if err := m.Attachments[len(m.Attachments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailBody_AttachmentBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttachmentBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttachmentBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &MailHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &MailBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Result{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailId = append(m.MailId[:0], dAtA[iNdEx:postIndex]...)
			if m.MailId == nil {
				m.MailId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BroadcastRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BroadcastRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BroadcastRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &MailHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &MailBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BroadcastResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BroadcastResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BroadcastResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Result{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailId = append(m.MailId[:0], dAtA[iNdEx:postIndex]...)
			if m.MailId == nil {
				m.MailId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMailCountRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMailCountRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMailCountRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = append(m.To[:0], dAtA[iNdEx:postIndex]...)
			if m.To == nil {
				m.To = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromTime", wireType)
			}
			m.FromTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMailCountResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMailCountResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMailCountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Result{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Read", wireType)
			}
			m.Read = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Read |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = append(m.To[:0], dAtA[iNdEx:postIndex]...)
			if m.To == nil {
				m.To = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &ListRequest_TimeAndID{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &ListRequest_TimeAndID{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ascend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ascend = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBroadcast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBroadcast = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRequest_TimeAndID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeAndID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeAndID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailId = append(m.MailId[:0], dAtA[iNdEx:postIndex]...)
			if m.MailId == nil {
				m.MailId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailHeaderWithID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailHeaderWithID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailHeaderWithID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailId = append(m.MailId[:0], dAtA[iNdEx:postIndex]...)
			if m.MailId == nil {
				m.MailId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &MailHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Result{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mails = append(m.Mails, &MailHeaderWithID{})
			if err := m.Mails[len(m.Mails)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = append(m.To[:0], dAtA[iNdEx:postIndex]...)
			if m.To == nil {
				m.To = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBroadcast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBroadcast = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailId = append(m.MailId[:0], dAtA[iNdEx:postIndex]...)
			if m.MailId == nil {
				m.MailId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MailIndex == nil {
				m.MailIndex = &MailIndex{}
			}
			if err := m.MailIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Result{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &MailBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MailIndex == nil {
				m.MailIndex = &MailIndex{}
			}
			if err := m.MailIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Result{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkAsReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkAsReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkAsReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MailIndex == nil {
				m.MailIndex = &MailIndex{}
			}
			if err := m.MailIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkAsReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkAsReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkAsReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Result{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkAsUnreadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkAsUnreadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkAsUnreadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MailIndex == nil {
				m.MailIndex = &MailIndex{}
			}
			if err := m.MailIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkAsUnreadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkAsUnreadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkAsUnreadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Result{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkAttachmentsAsReceivedRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkAttachmentsAsReceivedRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkAttachmentsAsReceivedRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MailIndex == nil {
				m.MailIndex = &MailIndex{}
			}
			if err := m.MailIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkAttachmentsAsReceivedResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkAttachmentsAsReceivedResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkAttachmentsAsReceivedResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Result{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckFailed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CheckFailed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetCustomDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetCustomDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetCustomDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MailIndex == nil {
				m.MailIndex = &MailIndex{}
			}
			if err := m.MailIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = append(m.CustomData[:0], dAtA[iNdEx:postIndex]...)
			if m.CustomData == nil {
				m.CustomData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetCustomDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetCustomDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetCustomDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Result{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSubscribe", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSubscribe = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = append(m.To[:0], dAtA[iNdEx:postIndex]...)
			if m.To == nil {
				m.To = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewMailNotification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewMailNotification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewMailNotification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OBSOLETEIsBroadcast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OBSOLETEIsBroadcast = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToList", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToList = append(m.ToList, make([]byte, postIndex-iNdEx))
			copy(m.ToList[len(m.ToList)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BroadcastMails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BroadcastMails = append(m.BroadcastMails, &MailHeaderWithID{})
			if err := m.BroadcastMails[len(m.BroadcastMails)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMail(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMail
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMail
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMail
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMail
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMail
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMail(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMail = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMail   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("mail.proto", fileDescriptorMail) }

var fileDescriptorMail = []byte{
	// 1266 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x4d, 0x6e, 0xdb, 0x46,
	0x14, 0x36, 0x29, 0x99, 0x91, 0x1e, 0x25, 0xd9, 0x19, 0xcb, 0x89, 0xcc, 0x14, 0xae, 0x42, 0xf4,
	0x47, 0x68, 0x1a, 0xa7, 0x51, 0xbb, 0x08, 0x5c, 0x18, 0xa8, 0x65, 0x27, 0xae, 0xd0, 0xc4, 0x09,
	0x46, 0x29, 0x02, 0x14, 0x45, 0x05, 0x8a, 0x1c, 0xc3, 0x13, 0x4b, 0xa4, 0x4a, 0x8e, 0xd2, 0x64,
	0xd7, 0x55, 0xef, 0xd0, 0x65, 0x2f, 0x53, 0x74, 0xd9, 0x23, 0x14, 0x39, 0x41, 0x8f, 0x50, 0xcc,
	0x1b, 0x92, 0x22, 0x69, 0xd9, 0xa9, 0x8c, 0xac, 0x34, 0xef, 0xff, 0xcd, 0xfb, 0xf9, 0x86, 0x02,
	0x98, 0x38, 0x7c, 0xbc, 0x33, 0x0d, 0x03, 0x11, 0x10, 0x7d, 0x3a, 0xb2, 0xff, 0x2d, 0x03, 0x3c,
	0x71, 0xf8, 0xf8, 0x5b, 0xe6, 0x78, 0x2c, 0x24, 0x04, 0xca, 0x27, 0x61, 0x30, 0x69, 0x69, 0x6d,
	0xad, 0x53, 0xa3, 0x78, 0x26, 0xb7, 0xa0, 0x2a, 0x7f, 0x87, 0x3e, 0x77, 0xcf, 0x5a, 0x3a, 0x0a,
	0x2a, 0x92, 0x71, 0xcc, 0xdd, 0x33, 0xd2, 0x00, 0x5d, 0x04, 0xad, 0x12, 0x72, 0x75, 0x11, 0x90,
	0x9b, 0x70, 0x4d, 0x04, 0x4a, 0xb5, 0x8c, 0x4c, 0x43, 0x04, 0xa8, 0xd8, 0x84, 0x55, 0xc1, 0xc5,
	0x98, 0xb5, 0x56, 0x91, 0xad, 0x08, 0xc9, 0x1d, 0x85, 0x9c, 0x9d, 0xb4, 0x0c, 0xc5, 0x45, 0x82,
	0x6c, 0x41, 0x65, 0x14, 0x78, 0x6f, 0x86, 0x63, 0xe6, 0xb7, 0xae, 0xb5, 0xb5, 0x4e, 0x9d, 0x5e,
	0x93, 0xf4, 0x63, 0xe6, 0x93, 0x6f, 0xc0, 0x74, 0x84, 0x70, 0xdc, 0xd3, 0x09, 0xf3, 0x45, 0xd4,
	0xaa, 0xb4, 0x4b, 0x1d, 0xb3, 0xbb, 0xbd, 0x33, 0x1d, 0xed, 0xcc, 0x6f, 0xb1, 0xb3, 0x9f, 0x6a,
	0xf4, 0xa4, 0x3f, 0x9a, 0x35, 0x21, 0x9f, 0x42, 0x59, 0xf0, 0x09, 0x6b, 0x55, 0xdb, 0x5a, 0xc7,
	0xec, 0x6e, 0x14, 0x4c, 0x9f, 0xf3, 0x09, 0xa3, 0xa8, 0x40, 0xee, 0x82, 0x11, 0x09, 0x47, 0xcc,
	0xa2, 0x16, 0xa0, 0xea, 0x66, 0x41, 0x75, 0x80, 0x42, 0x1a, 0x2b, 0x59, 0xbf, 0x6a, 0xb0, 0x56,
	0x08, 0x2c, 0xaf, 0xc7, 0x7d, 0x8f, 0xbd, 0xc6, 0x7a, 0xd6, 0xa9, 0x22, 0xe6, 0x97, 0xd6, 0xb3,
	0x97, 0x26, 0x50, 0xe6, 0x82, 0x4d, 0xe2, 0x5a, 0xe2, 0x59, 0x6a, 0xba, 0xc1, 0xcc, 0x17, 0x58,
	0xcb, 0x3a, 0x55, 0x84, 0xac, 0xb1, 0x94, 0x0e, 0xb9, 0x87, 0xc5, 0x2c, 0x53, 0x43, 0x92, 0x7d,
	0xcf, 0xea, 0x42, 0x59, 0xe6, 0x2f, 0x5d, 0x45, 0xcc, 0xf7, 0x30, 0x6a, 0x89, 0xe2, 0x99, 0xdc,
	0x00, 0x83, 0xbd, 0x9e, 0xf2, 0x90, 0x61, 0xd4, 0x12, 0x8d, 0x29, 0x6b, 0x0a, 0x86, 0xba, 0x88,
	0xb4, 0x0a, 0x99, 0xa3, 0xac, 0x2a, 0x14, 0xcf, 0xe4, 0x3e, 0x34, 0x33, 0xb5, 0x1b, 0x86, 0xcc,
	0x65, 0xfc, 0x15, 0xf3, 0xd0, 0x47, 0x85, 0x6e, 0x64, 0x64, 0x34, 0x16, 0x91, 0x0f, 0xc1, 0x74,
	0x67, 0x91, 0x08, 0x26, 0x43, 0xcf, 0x11, 0x4e, 0x7c, 0x1d, 0x50, 0xac, 0x43, 0x47, 0x38, 0xf6,
	0xef, 0x1a, 0x54, 0x64, 0x19, 0x7b, 0x81, 0xf7, 0x46, 0x06, 0x95, 0xad, 0x4d, 0x06, 0x4e, 0x9e,
	0xc9, 0x5e, 0xbe, 0xc7, 0x3a, 0xf6, 0xf8, 0x56, 0x52, 0x7d, 0x69, 0x96, 0xed, 0x70, 0xe0, 0xbd,
	0xc9, 0x35, 0xd8, 0xda, 0x85, 0x46, 0x5e, 0x7c, 0x41, 0x1b, 0x92, 0xd0, 0xfa, 0x3c, 0xb4, 0xbd,
	0x03, 0x06, 0x65, 0xd1, 0x6c, 0x2c, 0xe4, 0x60, 0x07, 0x67, 0x71, 0x2d, 0xf4, 0x00, 0xe7, 0x97,
	0x85, 0x61, 0x10, 0xa2, 0x7a, 0x95, 0x2a, 0xc2, 0x7e, 0x01, 0xe6, 0x80, 0xf9, 0x1e, 0x65, 0x3f,
	0xcf, 0x58, 0x24, 0xc8, 0x27, 0x60, 0x9c, 0xe2, 0x70, 0xa0, 0xa1, 0xd9, 0x6d, 0xe4, 0x47, 0x86,
	0xc6, 0x52, 0xd2, 0xce, 0x84, 0x36, 0xbb, 0xb5, 0xec, 0xd5, 0xe2, 0x44, 0xbe, 0x83, 0x9a, 0x72,
	0x1c, 0x4d, 0x03, 0x3f, 0x62, 0xc4, 0x06, 0x23, 0xc4, 0xc4, 0x62, 0xcf, 0x20, 0x6d, 0x54, 0xaa,
	0x34, 0x96, 0xc8, 0xb9, 0x90, 0xdb, 0x2d, 0xe7, 0x42, 0x55, 0xdd, 0x90, 0x64, 0xdf, 0xb3, 0x7f,
	0x84, 0xf5, 0x5e, 0x18, 0x38, 0x9e, 0xeb, 0x44, 0xe2, 0xfd, 0xa7, 0xfa, 0x0c, 0xae, 0x67, 0xbc,
	0xbf, 0x8f, 0x7c, 0x7b, 0xb0, 0x71, 0xc4, 0x84, 0x0c, 0x73, 0x20, 0x07, 0x3e, 0x49, 0x59, 0x61,
	0x8d, 0x96, 0x62, 0x4d, 0x02, 0x4c, 0xb8, 0xce, 0x6a, 0xaa, 0x11, 0x98, 0xe4, 0x0e, 0xd8, 0x1e,
	0x34, 0xf3, 0x3e, 0x96, 0x48, 0x4c, 0x62, 0x55, 0x20, 0x9c, 0x31, 0x3a, 0xad, 0x53, 0x45, 0xa4,
	0xfb, 0x51, 0x42, 0x26, 0x9e, 0xed, 0xdf, 0x74, 0x30, 0x1f, 0xf3, 0xe8, 0xc2, 0x14, 0xef, 0xc1,
	0x6a, 0x24, 0x9c, 0x50, 0xc4, 0xe5, 0xdb, 0x92, 0xc1, 0x32, 0xfa, 0x08, 0x37, 0xfb, 0xbe, 0xd7,
	0x3f, 0xa4, 0x4a, 0x8f, 0xdc, 0x81, 0x92, 0xdc, 0xdc, 0xd2, 0xbb, 0xd4, 0xa5, 0x96, 0xcc, 0x73,
	0xcc, 0x27, 0x3c, 0x85, 0x07, 0x24, 0xe4, 0xa6, 0x3b, 0x91, 0x2b, 0xbd, 0xac, 0xe2, 0xf4, 0xc6,
	0x14, 0xb9, 0x0d, 0x35, 0x1e, 0x0d, 0x47, 0x49, 0xab, 0x10, 0x72, 0x2b, 0xd4, 0xe4, 0x51, 0xda,
	0x3d, 0xeb, 0x01, 0x54, 0xd3, 0x10, 0xf2, 0xbe, 0x58, 0xd9, 0x18, 0x45, 0x10, 0x13, 0x33, 0x2d,
	0xd3, 0x73, 0x2d, 0x1b, 0xc0, 0xfa, 0x7c, 0x78, 0x5e, 0x70, 0x71, 0xda, 0x3f, 0xcc, 0x2a, 0x6b,
	0x59, 0xe5, 0xcc, 0xec, 0xe9, 0x97, 0xcd, 0x9e, 0xfd, 0x13, 0xd4, 0xd4, 0xed, 0x97, 0xe8, 0xdd,
	0x67, 0xb0, 0x2a, 0xa3, 0x24, 0xb0, 0xd1, 0xcc, 0xbb, 0x56, 0x99, 0x51, 0xa5, 0x62, 0xbf, 0x80,
	0xaa, 0x14, 0xf5, 0x11, 0x0e, 0x8a, 0xad, 0x2b, 0x96, 0x4b, 0x3f, 0x57, 0xae, 0x8b, 0x07, 0x78,
	0x17, 0xe0, 0x88, 0xa5, 0x43, 0xf1, 0xb9, 0x7a, 0x75, 0x87, 0x73, 0x0c, 0x32, 0xbb, 0xf5, 0x24,
	0x2f, 0x0c, 0x4e, 0xab, 0x93, 0xe4, 0x68, 0x0f, 0xc0, 0x44, 0xdb, 0x25, 0xee, 0xfc, 0xee, 0x1d,
	0xdd, 0x83, 0xfa, 0x21, 0x1b, 0x33, 0xc1, 0xae, 0x96, 0xd3, 0x57, 0xd0, 0x48, 0xcc, 0xff, 0x7f,
	0x5a, 0xf6, 0x3e, 0x5c, 0x7f, 0xe2, 0x84, 0x67, 0xfb, 0x11, 0x65, 0x8e, 0x77, 0xb5, 0xc0, 0x0f,
	0x80, 0x64, 0x5d, 0x2c, 0x11, 0xfc, 0x00, 0x36, 0x94, 0xe5, 0xf7, 0x7e, 0x78, 0xe5, 0xf0, 0xbb,
	0xd0, 0xcc, 0x3b, 0x59, 0x22, 0x81, 0x67, 0xd0, 0x46, 0xdb, 0xf9, 0xcb, 0xb4, 0x9f, 0x3e, 0x92,
	0x57, 0xcb, 0xe6, 0x25, 0xdc, 0xbe, 0xc4, 0xe3, 0x12, 0xf3, 0x72, 0x1b, 0x6a, 0xee, 0x29, 0x73,
	0xcf, 0x86, 0x27, 0x0e, 0x1f, 0xa7, 0xaf, 0xb9, 0x89, 0xbc, 0x47, 0xc8, 0xb2, 0x19, 0x34, 0x07,
	0x4c, 0x1c, 0xa4, 0xaf, 0xf6, 0x95, 0x32, 0x2e, 0x7e, 0x0b, 0xe8, 0xe7, 0xbe, 0x05, 0xbe, 0x86,
	0xcd, 0x42, 0x98, 0x25, 0x2a, 0xfc, 0x10, 0xd6, 0x07, 0xb3, 0x51, 0xe4, 0x86, 0x7c, 0x94, 0xce,
	0xb5, 0xda, 0xda, 0x28, 0x61, 0xc7, 0x0f, 0xb8, 0xc9, 0xa3, 0x54, 0x33, 0x5e, 0x74, 0x3d, 0x59,
	0x74, 0xfb, 0x0f, 0x0d, 0x36, 0x8e, 0xd9, 0x2f, 0xf2, 0x02, 0xc7, 0x81, 0xe0, 0x27, 0xdc, 0x75,
	0x04, 0x0f, 0x7c, 0xd2, 0x85, 0xcd, 0xa7, 0xbd, 0xc1, 0xd3, 0xc7, 0x0f, 0x9f, 0x3f, 0x1c, 0xe6,
	0x90, 0x40, 0xf9, 0xdc, 0x48, 0x84, 0xfd, 0x3c, 0x22, 0x88, 0x60, 0x38, 0xe6, 0x88, 0x17, 0x25,
	0xf5, 0xf9, 0x2b, 0x21, 0x8c, 0xec, 0xc1, 0x5a, 0xea, 0x60, 0xa8, 0x00, 0xaa, 0x74, 0x09, 0x40,
	0x35, 0x52, 0x65, 0x29, 0x8a, 0xba, 0x7f, 0xae, 0x42, 0x59, 0x9e, 0xc8, 0x1d, 0x28, 0xcb, 0xef,
	0x02, 0xb2, 0x26, 0xcd, 0x32, 0x9f, 0x1e, 0xd6, 0xfa, 0x9c, 0xa1, 0x4a, 0x68, 0xaf, 0x90, 0x5d,
	0xa8, 0xce, 0x53, 0xc3, 0x40, 0xc5, 0xcf, 0x00, 0x6b, 0xb3, 0xc0, 0x4d, 0x6d, 0x0f, 0xa0, 0x96,
	0x7d, 0x3f, 0xc9, 0x4d, 0xa9, 0xb8, 0xe0, 0x55, 0xb6, 0x5a, 0xe7, 0x05, 0xa9, 0x93, 0x3b, 0x50,
	0xc6, 0xdb, 0xaf, 0x15, 0x1e, 0x32, 0x95, 0x6d, 0x16, 0xdb, 0xed, 0x15, 0xd2, 0x81, 0xd2, 0x11,
	0x13, 0xa4, 0x11, 0xfb, 0x4b, 0x54, 0xd7, 0x52, 0x3a, 0xd5, 0xbc, 0x0f, 0x86, 0x82, 0x23, 0x72,
	0x5d, 0x0a, 0x73, 0xc8, 0x66, 0x91, 0x2c, 0x2b, 0x35, 0xd9, 0x93, 0x7f, 0x73, 0x12, 0x20, 0x21,
	0xf1, 0xa7, 0x7c, 0x01, 0x9b, 0xac, 0x1b, 0x45, 0x76, 0xb6, 0x1a, 0x59, 0x20, 0x50, 0xd5, 0x58,
	0x80, 0x2f, 0xaa, 0x1a, 0x8b, 0x30, 0xc3, 0x5e, 0x21, 0x2f, 0x61, 0xeb, 0xc2, 0xfd, 0x25, 0x1f,
	0xa5, 0x86, 0x97, 0x00, 0x86, 0xf5, 0xf1, 0x3b, 0xb4, 0xd2, 0x58, 0x8f, 0xa0, 0x9e, 0x5b, 0x2c,
	0xd2, 0x52, 0xf3, 0x71, 0x7e, 0xa5, 0xad, 0xad, 0x05, 0x92, 0xd4, 0xcf, 0x31, 0xdc, 0x3c, 0x62,
	0x62, 0xc1, 0x7a, 0x44, 0x6a, 0xa0, 0x8a, 0x0b, 0x68, 0x61, 0x65, 0x16, 0xe8, 0xdb, 0x2b, 0x1d,
	0xed, 0x0b, 0xad, 0xf7, 0xc1, 0x5f, 0x6f, 0xb7, 0xb5, 0xbf, 0xdf, 0x6e, 0x6b, 0xff, 0xbc, 0xdd,
	0xd6, 0x7e, 0x68, 0xc8, 0x4d, 0xb8, 0x1b, 0xb1, 0xf0, 0x15, 0x0b, 0xef, 0x4d, 0x47, 0x23, 0x03,
	0xff, 0x98, 0x7e, 0xf9, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x06, 0x37, 0xcc, 0x4b, 0xa6, 0x0e,
	0x00, 0x00,
}
